# Looping with `range`

## Topics

- One- and two-input forms of `range`
- Project Euler problem #1
- Three-input version with a non-unit step size
- Looping backwards

## Single-input `range`

The built-in `range` function is our basic tool for looping over **sequences of numbers**. The basic form of `range` takes one input:
```
# Single-input range
for i in range(10):
    print(i)
```
Single-letter variable names like `i`, `j`, and `k` are traditional for numeric loops. In particular, most programmers use `i` as their default loop variable name when writing a numeric `for` loop.

If you run this program, you'll see the following output values:
```
0
1
2
3
4
5
6
7
8
9
```
The single-input `range` starts at ***zero*** and goes ***up to but does not include*** the given stopping number.

For example, the loop below iterates from 0 to 99, but does not include 100.
```
for j in range(100):
    print(j)
```

## Two-input `range`

The two-input `range` specifies the starting and stopping values of the loop. The stopping behavior is the same as the one-input version: go up to ***but not including*** the given ending value. For example, the loop below would iterate from 1 to ***19***:
```
# Loop from 1 to 19
for j in range(1, 20):
    print(j)
```

Recall, from the last class, the *selector pattern* that combined a `for` loop with an `if` statement to select certain values of interest from the sequence. The loop below prints the numbers from 1 to 30 that are divisible by 3. Notice that the second input to `range` is 31, so that 30 is included in the loop.
```
# Numbers 1 to 30 divisible by 3
for n in range(1, 31):
    if n % 3 == 0:
        print(n)
```

## Project Euler #1
A second common loop pattern is the *accumulator pattern*, which uses a variable declared before the loop to sum up values of interest.

[Project Euler](https://projecteuler.net/) is a site with fun mathematical problems. Problem #1 says,
>If we list all the natural numbers below that are multiples of 3 or 5, we get 3, 5, 6, and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

A solution to this problem uses a loop from 1 to 999 with an `if` statement to select the multiples of 3 or 5. An accumulator variable, named `total` in the code below, adds up the values of `n` that satisfy the condition.
```
"""
Project Euler #1
"""

total = 0
for n in range(1, 1000):
    if n % 3 == 0 or n % 5 == 0:
        total += i

print(total)
```
Notice that `total` is declared **before** the loop. This is required for the sum to work correctly. For example, the version below would reset `total` to 0 on every iteration.
```
for n in range(1, 1000):
    total = 0
    if n % 3 == 0 or n % 5 == 0:
        total += i
```

## Three-input `range`

`range` can take a third input that gives the step size. The loop below starts at 1 and counts up to 20 by 3.
```
for i in range(1, 20, 3):
    print(i)
```
The output is:
```
1
4
7
10
13
16
19
```
The loop runs up to the final value that is strictly less than the stopping value given by the second input. Sometimes this can be tricky to reason about. For example, consider this loop:
```
for i in range(4, 20, 4):
    print(i)
```
The values of this sequence are:
```
4
8
12
16
```
The next value would be 20, which is given stopping value, so the loop ends with 16 as the last value.

## Looping backwards

You can use the three-input version to loop backwards with a negative step size:
```
# Loop from 20 down to, but not including, 1
for i in range(20, 1, -1):
    print(i)
```
The challenge of backwards looping is, again, making sure the final value is correct. The loop above starts at 20 and goes down to, ***but does not include***, the stopping value of 1, so its last value is ***2***.

Using a backwards step size other than -1 is allowed, but tricky.
```
# Final value is 3
for n in range(15, 1, -4):
    print(i)
```
The sequence of values generated by this loop is 15, 11, 7, and 3.

In general, be careful with backwards loops.

## Other loop notes

If the starting value is greater than or equal to the stopping value, the loop won't execute. For example, you might try looping backwards using the following, but the loop doesn't run.
```
# starting value >= stopping value ---> loop doesn't execute
for i in range(20, 1):
    print(i)
```

Inputs must be whole numbers. You can't use `range` to iterate over a decimal interval.
```
# Not allowed
for percent in range(0, 1.0, .01):
    print(percent)
````
